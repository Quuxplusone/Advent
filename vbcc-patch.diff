diff --git a/vbcc/Makefile b/vbcc/Makefile
index 1c700ba..00dcc2b 100644
--- a/vbcc/Makefile
+++ b/vbcc/Makefile
@@ -4,7 +4,7 @@
 HOSTID =
 
 # used to compile vbcc, vc, ucpp, etc. for the selected host
-CC = gcc -std=c9x -g -DHAVE_AOS4 #-fsanitize=address #-DHAVE_ECPP -DHAVE_MISRA
+CC = gcc -std=c9x -g -DHAVE_AOS4 $(CFLAGS) #-fsanitize=address #-DHAVE_ECPP -DHAVE_MISRA
 LDFLAGS = -lm
 
 # used to compile dtgen and osekrm natively
diff --git a/vbcc/config/ppc b/vbcc/config/ppc
new file mode 100644
index 0000000..59e2927
--- /dev/null
+++ b/vbcc/config/ppc
@@ -0,0 +1,5 @@
+-cc=$VBCC/bin/vbccppc -quiet %s -o=%s %s -O=%ld
+-ccv=$VBCC/bin/vbccppc %s -o=%s %s -O=%ld
+-as=cp %s %s
+-ld=echo "Don't know how to link PowerPC code" 1>&2; exit 0
+-rm=rm %s
diff --git a/vbcc/config/z b/vbcc/config/z
new file mode 100644
index 0000000..fdd0f32
--- /dev/null
+++ b/vbcc/config/z
@@ -0,0 +1,5 @@
+-cc=$VBCC/bin/vbccz -quiet %s -o=%s %s -O=%ld
+-ccv=$VBCC/bin/vbccz %s -o=%s %s -O=%ld
+-as=cp %s %s
+-ld=echo "Don't know how to link Z-machine code" 1>&2; exit 0
+-rm=rm %s
diff --git a/vbcc/cse.c b/vbcc/cse.c
index e180d3d..cfb0f1a 100644
--- a/vbcc/cse.c
+++ b/vbcc/cse.c
@@ -164,7 +164,7 @@ void num_exp(void)
     if(DEBUG&1024){ printf("num_exp loop1\n");}
     for(p=first_ic;p;p=p->next){
         c=p->code;
-        if(p->z.flags&&p->q1.flags&&(c!=ASSIGN||(p->q1.flags&DREFOBJ)||(static_cse&&(p->q1.flags&(VAR|VARADR))==VAR&&ISSCALAR(p->q1.v->vtyp->flags)&&(p->q1.v->storage_class==EXTERN||p->q1.v->storage_class==STATIC)))&&c!=MOVETOREG&&c!=MOVEFROMREG){
+        if(p->z.flags&&p->q1.flags&&(c!=ASSIGN||((p->q1.flags&DREFOBJ)&&ISSCALAR(q1typ(p)))||(static_cse&&(p->q1.flags&(VAR|VARADR))==VAR&&ISSCALAR(q1typ(p))&&(p->q1.v->storage_class==EXTERN||p->q1.v->storage_class==STATIC)))&&c!=MOVETOREG&&c!=MOVEFROMREG){
             p->expindex=ecount++;
             if(c==ADD||c==MULT||(c>=OR&&c<=AND)){
                 if(p->q2.flags&&compare_objs(&p->q1,&p->q2,p->typf)<0&&(USEQ2ASZ||compare_objs(&p->q1,&p->z,p->typf))){
diff --git a/vbcc/declaration.c b/vbcc/declaration.c
index e039d89..81fbb3b 100644
--- a/vbcc/declaration.c
+++ b/vbcc/declaration.c
@@ -1019,6 +1019,10 @@ type *declaration_specifiers(void)
   if(type_qualifiers&(XSIGNED|UNSIGNED))
     if(!ISINT(typ))
       error(58);
+  if ((type_qualifiers & XSIGNED) && (typ == CHAR)) {
+    type_qualifiers |= SIGNED_CHARACTER;
+  }
+  type_qualifiers &= ~XSIGNED;
   new->flags=typ|type_qualifiers;
   new->attr=attr;
   return new;
diff --git a/vbcc/ic.c b/vbcc/ic.c
index 4e76920..8503109 100644
--- a/vbcc/ic.c
+++ b/vbcc/ic.c
@@ -1,5 +1,6 @@
 /*  $VER: vbcc (ic.c) $Revision: 1.65 $  */
 
+#include <assert.h>
 #include "vbc.h"
 #include "opt.h"
 
@@ -583,6 +584,199 @@ np gen_libcall(char *fname,np arg1,type *t1,np arg2,type *t2)
   return new;
 }
 
+#if INLINE_PUTS_ON_Z_MACHINE
+
+/* This function serves a dual purpose: it turns the const_list into a nice
+ * C string, but it also checks to see if it's null-terminated, and if
+ * it's not, we simply return NULL. Our caller is responsible for doing the
+ * right thing in that case. */
+static char *const_list_to_string(struct const_list *cl)
+{
+    int len = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++len) {
+        int ch = cx->other->val.vchar;
+        switch (ch) {
+            case '\0': if (cx->next != NULL) return NULL; break;
+            case '\t': case '\n': /* okay */ break;
+            default:
+                if (cx->next == NULL) return NULL;  /* not null-terminated */
+                break;
+        }
+    }
+    /* Okay, the string is a valid, printable string. */
+    char *text = mymalloc(len);
+    int i = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++i) {
+        text[i] = cx->other->val.vchar;
+    }
+    return text;
+}
+
+static struct const_list *string_to_const_list(const char *text)
+{
+    struct const_list *cl = NULL;
+    struct const_list **pp = &cl;
+    for (int i=0; /*true*/; ++i) {
+        *pp = mymalloc(CLS);
+        (*pp)->tree = NULL;
+        (*pp)->idx = i;
+        (*pp)->val.vmax = 0;
+        (*pp)->other = mymalloc(CLS);
+        (*pp)->other->next = (*pp)->other->other = NULL;
+        (*pp)->other->tree = NULL;
+        (*pp)->other->idx = 0;
+        (*pp)->other->val.vchar = text[i];
+        pp = &(*pp)->next;
+        *pp = NULL;
+        if (text[i] == '\0')
+            break;
+    }
+    return cl;
+}
+
+static void emit_print_num(np p, struct argument_list *arg)
+{
+    assert(strcmp(p->left->left->o.v->identifier, "printf") == 0);
+
+    static struct Var *internal_print_num = NULL;
+    static struct Typ *voidfunc_ptr_typ = NULL;
+    if (internal_print_num == NULL) {
+        struct Typ voidt = {VOID};
+        struct Typ *voidfunctyp = new_typ();
+        voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+        voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+        voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+        voidfunctyp->flags = FUNKT;
+        internal_print_num = add_var("XXinternal_print_num", voidfunctyp, EXTERN, NULL);
+        internal_print_num->fi = new_fi();
+        internal_print_num->fi->inline_asm = malloc(sizeof("\t@print_num r0;\n"));
+        strcpy(internal_print_num->fi->inline_asm, "\t@print_num r0;\n");
+
+        voidfunc_ptr_typ = new_typ();
+        voidfunc_ptr_typ->next = clone_typ(voidfunctyp);
+        voidfunc_ptr_typ->flags = POINTER_TYPE(voidfunc_ptr_typ->next);
+    }
+
+    struct argument_list *saved_alist = p->alist;
+    struct Var *saved_ov = p->left->left->o.v;
+    struct Typ *saved_ntyp = p->left->ntyp;
+    p->alist = arg;
+    assert(arg->next == NULL);
+    p->left->left->o.v = internal_print_num;
+    p->left->ntyp = voidfunc_ptr_typ;
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+
+    p->left->left->o.v = saved_ov;
+    p->left->ntyp = saved_ntyp;
+    p->alist = saved_alist;
+}
+
+/* Emit a call to printf() with the given arguments. We expect that parameter "p"
+ * will point to an existing printf call, so all we need to do is swap out the
+ * arguments. */
+static void emit_printf(np p, const char *fmt, struct argument_list *other_args)
+{
+    struct argument_list *al = p->alist;
+    assert(al->arg->flags == ADDRESSA);
+    assert(al->arg->left->flags == STRING);
+    struct const_list *saved_cl = al->arg->left->cl;
+    struct const_list *cl = string_to_const_list(fmt);
+    al->arg->left->cl = cl;
+    /* Shrink the declared size of the string literal's char-array type. */
+    int saved_size = al->arg->left->ntyp->size;
+    int length = 0;
+    for (struct const_list *sx = cl; sx; sx = sx->next)
+        ++length;
+    assert(length >= 1);
+    al->arg->left->ntyp->size = length;
+
+    struct argument_list *saved_alist = p->alist;
+    struct argument_list *new_alist = mymalloc(sizeof(struct argument_list));
+    new_alist->arg = al->arg;
+    new_alist->next = other_args;
+    p->alist = new_alist;
+
+    assert(strcmp(p->left->left->o.v->identifier, "printf") == 0);
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+
+    p->alist = saved_alist;
+    al->arg->left->cl = saved_cl;
+    al->arg->left->ntyp->size = saved_size;
+    free(new_alist);
+}
+
+static void emit_puts(np p, const char *text)
+{
+    extern const char *z_optimize_puts_name;
+    assert(*text != '\0');
+    int cap = strlen(z_optimize_puts_name) + strlen(text) + 16;
+    char *inline_asm = mymalloc(cap);
+
+    sprintf(inline_asm, "\t%s(\"", z_optimize_puts_name);
+    int len = strlen(inline_asm);
+    for (int i=0; text[i] != '\0'; ++i) {
+        cap += strlen(z_optimize_puts_name) + 32;
+        inline_asm = myrealloc(inline_asm, cap);
+        if ((text[i] & 0x80) != 0) {
+            unsigned int w = text[i] & 0xFF;
+            if (0xC2 <= w && w <= 0xDF) {
+                w &= 0x1F;
+                w = (w << 6) | (text[++i] & 0x3F);
+            } else if (0xE0 <= w && w <= 0xEF) {
+                w &= 0x0F;
+                w = (w << 6) | (text[++i] & 0x3F);
+                w = (w << 6) | (text[++i] & 0x3F);
+            } else {
+                ierror(0);  /* unsupported or invalid UTF-8 encoding */
+            }
+            sprintf(inline_asm+len, "\");\n"
+                                    "\t@print_unicode $%04X;\n"
+                                    "\t%s(\"", w, z_optimize_puts_name);
+            len = strlen(inline_asm);
+        } else if (text[i] == '^' || text[i] == '~') {
+            sprintf(inline_asm+len, "@@%d\");\n"
+                                    "\t%s(\"", text[i], z_optimize_puts_name);
+            len = strlen(inline_asm);
+        } else {
+            switch (text[i]) {
+                case '\n': inline_asm[len++] = '^'; break;
+                case '\t': strcpy(inline_asm+len, "@{9}"); len += 4; break;
+                case '"': inline_asm[len++] = '~'; break;
+                case '@': strcpy(inline_asm+len, "@{40}"); len += 5; break;
+                case '\\': strcpy(inline_asm+len, "@{5c}"); len += 5; break;
+                default:
+                    /* This should have been assured by const_list_to_string(). */
+                    assert(32 <= text[i] && text[i] <= 126);
+                    inline_asm[len++] = text[i];
+                    break;
+            }
+        }
+    }
+    strcpy(inline_asm+len, "\");\n"); len += 3;
+
+    char pfname[50];
+    static int counter = 0;
+    struct Typ voidt = {VOID};
+    struct Typ *voidfunctyp = new_typ();
+    sprintf(pfname, "XXinternal_pf_%07x_puts", ++counter);
+    voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+    voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+    voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+    voidfunctyp->flags = FUNKT;
+    struct Var *pseudofunc = add_var(pfname, voidfunctyp, EXTERN, NULL);
+    pseudofunc->fi = new_fi();
+    pseudofunc->fi->inline_asm = inline_asm;
+
+    struct Var *saved_v = p->left->left->o.v;
+    struct argument_list *saved_alist = p->alist;
+    p->left->left->o.v = pseudofunc;
+    p->alist = NULL;
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+    p->left->left->o.v = saved_v;
+    p->alist = saved_alist;
+}
+
+#endif /* INLINE_PUTS_ON_Z_MACHINE */
 
 void gen_IC(np p,int ltrue,int lfalse)
 /*  Erzeugt eine IC-Liste aus einer expression      */
@@ -1116,6 +1310,132 @@ void gen_IC(np p,int ltrue,int lfalse)
         IC *merk_fp,*lp;
 	unsigned int merk_opushed=opushed;
 #endif
+
+#if INLINE_PUTS_ON_Z_MACHINE
+	/* [ajo] The following code optimizes puts("hello") into a single
+	 * Z-machine opcode: print "hello". This cuts down a little bit on
+	 * code size, but greatly on static data size, because (as far as I
+	 * know) the Z-machine stores text strings differently from regular
+	 * static data. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "puts")) {
+            /* Generating IC for puts() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING &&
+		al->next == NULL) {
+                /* Generating IC for puts() of a string literal */
+                char *text = const_list_to_string(al->arg->left->cl);
+		if (text != NULL) {
+		    text = myrealloc(text, strlen(text)+2);
+		    strcat(text, "\n");
+		    emit_puts(p, text);
+		    free(text);
+		    return;
+		}
+            }
+        }
+
+	/* [ajo] The following code optimizes printf("prefix%ssuffix\n", arg)
+	 * into printf("prefix%s", arg); puts("suffix");
+	 * Again, this is very useful on the Z-machine. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "printf")) {
+            /* Generating IC for printf() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING) {
+                /* Generating IC for printf("literal", ...) */
+		char *fmt = const_list_to_string(al->arg->left->cl);
+		if (fmt == NULL) {
+		    /* The format string contains some unprintable characters.
+		     * Fall back on the standard library's printf()
+		     * implementation. */
+		} else if (strcmp(fmt, "%s") == 0) {
+		    /* This should compile to fputs(), but for now let's allow
+		     * it also to fall back on the default printf(). */
+		} else if (fmt[0] == '%' && fmt[1] != 'd' && fmt[1] != 's') {
+		    /* The format string *begins* with an unrecognized
+		     * format specifier. We can't optimize this one. */
+		} else {
+		    int start = 0;
+		    int end;
+		    struct argument_list *current_argument = al->next;
+		    for (end = 0; fmt[end] != '\0'; ) {
+			if (fmt[end] != '%') {
+			    ++end;
+			    continue;
+			}
+			/* We've hit a format specifier. */
+			if (start != end) {
+			    /* There's some plaintext to print before we
+			     * get to this format specifier. */
+			    fmt[end] = '\0';
+			    emit_puts(p, fmt+start);
+			    fmt[end] = '%';
+			    start = end;
+			}
+			assert(start == end);
+			assert(fmt[start] == '%');
+			if (fmt[start+1] == 'd') {
+			    struct argument_list *saved_al = current_argument->next;
+			    current_argument->next = NULL;
+			    emit_print_num(p, current_argument);
+			    current_argument->next = saved_al;
+			    /* Advance to the next unconsumed argument. */
+			    current_argument = current_argument->next;
+			    start = end = start+2;
+			} else if (fmt[start+1] == 's') {
+			    struct argument_list *saved_al = current_argument->next;
+			    current_argument->next = NULL;
+			    /* Recurse to handle this one. */
+			    emit_printf(p, "%s", current_argument);
+			    current_argument->next = saved_al;
+			    /* Advance to the next unconsumed argument. */
+			    current_argument = current_argument->next;
+			    start = end = start+2;
+			} else if (fmt[start+1] == '%') {
+			    emit_puts(p, "%");
+			    start = end = start+2;
+			} else {
+			    /* This format specifier is unrecognized. It might
+			     * for example be "%x" or "%02.5d". We must be
+			     * conservative and fall back on the standard
+			     * library's printf() for the entire rest of the
+			     * format string. */
+			    emit_printf(p, fmt+start, current_argument);
+			    free(fmt);
+			    return;
+			}
+		    }
+		    if (start != end) {
+			/* There's plaintext at the end of the format string. */
+			emit_puts(p, fmt+start);
+		    }
+		    /* If we've reached here, we're done emitting the
+		     * optimized code, and we can stop. But we do need
+		     * to make sure we've evaluated all the arguments,
+		     * even if the user wrote something like
+		     *     printf("hello world\n", ++foo);
+		     * where the arguments go unused. */
+		    while (current_argument != NULL) {
+			gen_IC(current_argument->arg, /*ltrue=*/0, /*lfalse=*/0);
+			current_argument = current_argument->next;
+		    }
+		    free(fmt);
+		    return;
+		}
+		free(fmt);
+	    }
+        }
+#endif /* INLINE_PUTS_ON_Z_MACHINE */
+
         if(p->left->flags==ADDRESS&&p->left->left->flags==IDENTIFIER){
             Var *v;
             gen_IC(p->left,0,0); r=1;
diff --git a/vbcc/loop.c b/vbcc/loop.c
index b0190c6..8a01c4d 100644
--- a/vbcc/loop.c
+++ b/vbcc/loop.c
@@ -1605,15 +1605,17 @@ int do_unroll(int donothing)
       IC *new,*mc; Var *v; int out=++label,code;
       long i; type *t;static type tptrdiff={0};
       IC tmp;
+      static type totherwise={0};
       if(DEBUG&1024) printf("reversing loop\n");
       if(ISPOINTER(cmp->typf)){
 	tptrdiff.flags=PTRDIFF_T(cmp->typf);
 	t=&tptrdiff;
       }else{
+	t=&totherwise;
 	if(cmp->q1.flags&VAR)
-	  t=cmp->q1.v->vtyp;
+	  t->flags=q1typ(cmp);
 	else
-	  t=cmp->q2.v->vtyp;
+	  t->flags=q2typ(cmp);
       }
       v=add_tmp_var(clone_typ(t));
       new=new_IC();
diff --git a/vbcc/machines/z/machine.c b/vbcc/machines/z/machine.c
index a242fff..a2e3f1d 100644
--- a/vbcc/machines/z/machine.c
+++ b/vbcc/machines/z/machine.c
@@ -68,7 +68,9 @@ int g_flags[MAXGF] = {
 	0,
 	0,
 	0,
-	0
+	0,
+	0,
+	STRINGFLAG
 };
 char *g_flags_name[MAXGF] = {
 	"module-name",
@@ -76,7 +78,9 @@ char *g_flags_name[MAXGF] = {
 	"trace-all",
 	"safe-branches",
 	"comment-ic",
-	"comment-misc"
+	"comment-misc",
+	"patch-not",
+	"opt-puts"
 };
 union ppi g_flags_val[MAXGF];
 
@@ -180,7 +184,7 @@ int regsa[] = {
 
 int regscratch[] = {
 	0,
-	0,	0,	0,	0,	0,	0,	0,	0,
+	0,	1,	0,	0,	0,	0,	0,	0,
 	0,	0,	0,	0,	0,	0};
 
 /* Default state for register parameter passing. */
@@ -197,6 +201,10 @@ static char* labelprefix = "L";
 
 static char* modulename;
 
+/* Name of the function to use for "puts" optimization. */
+
+const char *z_optimize_puts_name;
+
 /* Stack frame layout:
  *
  *  --------------
@@ -243,8 +251,8 @@ enum {
 
 /* Some useful zops. */
 
-struct zop zop_zero = {ZOP_CONSTANT, {constant: 0}};
-struct zop zop_xp = {ZOP_REG, {reg: XP}};
+struct zop zop_zero = {ZOP_CONSTANT, {.constant = 0}};
+struct zop zop_xp = {ZOP_REG, {.reg = XP}};
 struct zop zop_stack = {ZOP_STACK, 0};
 
 /* Temporaries used to store comparison register numbers. */
@@ -357,20 +365,33 @@ static zshort xword(zmax val, int word)
 
 static void dump_type(FILE* fp, int typf)
 {
-	switch (typf)
+	if (typf & CONST) fprintf(fp, "CONST|");
+	if (typf & VOLATILE) fprintf(fp, "VOLATILE|");
+	if (typf & UNSIGNED) fprintf(fp, "UNSIGNED|");
+	if (typf & BOOLEAN) fprintf(fp, "BOOLEAN|");
+	if (typf & SIGNED_CHARACTER) fprintf(fp, "SIGNED|");
+	switch (typf & NQ)
 	{
-		case VOID:	fprintf(fp, "VOID"); break;
 		case CHAR:	fprintf(fp, "CHAR"); break;
 		case SHORT:	fprintf(fp, "SHORT"); break;
 		case INT:	fprintf(fp, "INT"); break;
 		case LONG:	fprintf(fp, "LONG"); break;
+		case LLONG:	fprintf(fp, "LLONG"); break;
+		case FLOAT:	fprintf(fp, "FLOAT"); break;
+		case DOUBLE:	fprintf(fp, "DOUBLE"); break;
+		case LDOUBLE:	fprintf(fp, "LDOUBLE"); break;
+		case VOID:	fprintf(fp, "VOID"); break;
 		case POINTER:	fprintf(fp, "POINTER"); break;
-		case STRUCT:	fprintf(fp, "STRUCT"); break;
 		case ARRAY:	fprintf(fp, "ARRAY"); break;
+		case STRUCT:	fprintf(fp, "STRUCT"); break;
 		case UNION:	fprintf(fp, "UNION"); break;
+		case ENUM:	fprintf(fp, "ENUM"); break;
 		case FUNKT:	fprintf(fp, "FUNKT"); break;
 		default:	fprintf(fp, "unknown %X", typf);
 	}
+	if (typf & ~(NQ|CONST|VOLATILE|UNSIGNED|BOOLEAN|SIGNED_CHARACTER)) {
+		fprintf(fp, "|0x%x", (unsigned)(typf & ~(NQ|CONST|VOLATILE|UNSIGNED|BOOLEAN|SIGNED_CHARACTER)));
+	}
 }
 
 /* Debug function: outputs the obj. */
@@ -391,7 +412,7 @@ static void dump_obj(FILE* fp, struct obj* obj, int typf)
 	if (f & VARADR)
 		fprintf(fp, "&");
 
-	if (f == KONST)
+	if (f & KONST)
 	{
 		switch (typf & NU)
 		{
@@ -416,7 +437,7 @@ static void dump_obj(FILE* fp, struct obj* obj, int typf)
 				break;
 
 			case UNSIGNED|INT:
-				fprintf(fp, "[uint #%d]", obj->val.vuint);
+				fprintf(fp, "[uint #%u]", obj->val.vuint);
 				break;
 
 			case LONG:
@@ -428,25 +449,19 @@ static void dump_obj(FILE* fp, struct obj* obj, int typf)
 				break;
 
 			case FLOAT:
-				fprintf(fp, "[float #%04X]", obj->val.vfloat);
+				fprintf(fp, "[float #%f]", obj->val.vfloat);
 				break;
 
 			case DOUBLE:
-				fprintf(fp, "[double #%08X]", obj->val.vdouble);
+				fprintf(fp, "[double #%f]", obj->val.vdouble);
 				break;
-#if 0
+
 			case POINTER:
-				fprintf(fp, "[pointer #%04X]", obj->val.vpointer);
+				fprintf(fp, "[pointer #%04X]", obj->val.vuint);
 				break;
-#endif
 		}
 	}
-	else if (f == REG)
-		fprintf(fp, "[reg %s]", regnames[obj->reg]);
-	else if (f == (REG|DREFOBJ))
-		fprintf(fp, "[deref reg %s]", regnames[obj->reg]);
-	//else if (f & VAR)
-	else
+	if (f & VAR)
 	{
 		fprintf(fp, "[var ");
 		dump_type(fp, typf);
@@ -458,14 +473,16 @@ static void dump_obj(FILE* fp, struct obj* obj, int typf)
 			zmax offset = obj->v->offset;
 			//if (offset < 0)
 			//	offset = -(offset+maxalign);
-			fprintf(fp, " at fp%+d", offset);
+			fprintf(fp, " at fp%+ld", offset);
 		}
 
-		fprintf(fp, "+%ld", obj->val.vlong);
+		fprintf(fp, "+%d", obj->val.vlong);
 
 		if (f & REG)
 			fprintf(fp, " in %s", regnames[obj->reg]);
 		fprintf(fp, "]");
+	} else if (f & REG) {
+		fprintf(fp, "[reg %s]", regnames[obj->reg]);
 	}
 }
 
@@ -503,19 +520,7 @@ static void dump_ic(FILE* fp, struct IC* ic)
 		case MINUS:		p = "MINUS";		break;
 		case ADDRESS:		p = "ADDRESS";		break;
 		case CALL:		p = "CALL";		break;
-#if 0
-		case CONVCHAR:		p = "CONVCHAR";		break;
-		case CONVSHORT:		p = "CONVSHORT";	break;
-		case CONVINT:		p = "CONVINT";		break;
-		case CONVLONG:		p = "CONVLONG";		break;
-		case CONVFLOAT:		p = "CONVFLOAT";	break;
-		case CONVDOUBLE:	p = "CONVDOUBLE";	break;
-		case CONVPOINTER:	p = "CONVPOINTER";	break;
-		case CONVUCHAR:		p = "CONVUCHAR";	break;
-		case CONVUSHORT:	p = "CONVUSHORT";	break;
-		case CONVUINT:		p = "CONVUINT";		break;
-		case CONVULONG:		p = "CONVULONG";	break;
-#endif
+		case CONVERT:		p = "CONVERT";		break;
 		case ALLOCREG:		p = "ALLOCREG";		break;
 		case FREEREG:		p = "FREEREG";		break;
 		case COMPARE:		p = "COMPARE";		break;
@@ -558,11 +563,11 @@ static void dump_ic(FILE* fp, struct IC* ic)
 			goto epilogue;
 	}
 	
-	dump_obj(fp, &ic->q1, ic->typf);
+	dump_obj(fp, &ic->q1, q1typ(ic));
 	fprintf(fp, " ");
-	dump_obj(fp, &ic->q2, ic->typf);
+	dump_obj(fp, &ic->q2, q2typ(ic));
 	fprintf(fp, " -> ");
-	dump_obj(fp, &ic->z, ic->typf);
+	dump_obj(fp, &ic->z, ztyp(ic));
 
 epilogue:
 	if (g_flags[2] & USEDFLAG)
@@ -580,6 +585,10 @@ int init_cg(void)
 	if (!modulename)
 		modulename = "";
 
+	z_optimize_puts_name = g_flags_val[7].p;
+	if (!z_optimize_puts_name)
+		z_optimize_puts_name = "print (string) ";
+
   /*  Initialize the min/max-settings. Note that the types of the     */
   /*  host system may be different from the target system and you may */
   /*  only use the smallest maximum values ANSI guarantees if you     */
@@ -647,17 +656,17 @@ int dangerous_IC(struct IC *ic)
 	if ((ic->q1.flags & DREFOBJ) ||
 	    (ic->q2.flags & DREFOBJ) ||
 	    (ic->z.flags & DREFOBJ))
-		return 0;
+		return 1;
 
 	/* Division or modulo? */
 
 	if ((ic->code == DIV) ||
 	    (ic->code == MOD))
-		return 0;
+		return 1;
 
 	/* Safe, as far as we can tell. */
 
-	return 1;
+	return 0;
 }
 
 /* Returns zero if the code for converting type p->ntyp to type typ is a noop.
@@ -738,7 +747,7 @@ void gen_var_head(FILE* fp, struct Var* var)
 			fprintf(fp, "Array _%s ->\n",
 				var->identifier);
 			currentvar.type = EXTERN;
-			currentvar.val.identifier = strdup(var->identifier);
+			currentvar.val.identifier = mystrdup(var->identifier);
 			currentvar.offset = 0;
 			break;
 			
@@ -757,7 +766,13 @@ void gen_var_head(FILE* fp, struct Var* var)
 
 void gen_ds(FILE *fp, zmax size, struct Typ *typ)
 {
-	fprintf(fp, " %ld\n", size);
+	if (size == 1 || currentvar.offset != 0) {
+		for (int i=0; i < (int)size; ++i) {
+			fprintf(fp, " (0)\n");
+		}
+	} else {
+		fprintf(fp, " %d\n", (int)size);
+	}
 	currentvar.offset += size;
 }
 
@@ -805,7 +820,7 @@ void gen_dc(FILE *fp, int typf, struct const_list *p)
 				{
 					case EXTERN:
 						fixup->value.type = EXTERN;
-						fixup->value.val.identifier = strdup(obj->v->identifier);
+						fixup->value.val.identifier = mystrdup(obj->v->identifier);
 						break;
 
 					case STATIC:
@@ -852,8 +867,8 @@ static int find_varargs(void)
 	int offset = 0;
 	struct reg_handle rh = empty_reg_handle;
 	struct struct_declaration* sd = function->vtyp->exact;
-	int stackalign;
 	int i;
+	struct Typ *parameter_type;
 
 	for (i=0; i<sd->count; i++)
 	{
@@ -867,21 +882,12 @@ static int find_varargs(void)
 		if (((*sd->sl)[i].styp->flags & NQ) == VOID)
 			ierror(0);
 
-		/* Does the backend want to assign it to a register? */
-
-		if (reg_parm(&rh, (*sd->sl)[i].styp, 0, 0))
-			continue;
-
 		/* Add on the size of this parameter. */
 
-		offset += sizetab[(*sd->sl)[i].styp->flags & NQ];
-
-		/* Stack align. */
-
-		stackalign = align[(*sd->sl)[i].styp->flags & NQ];
-		offset = ((offset+1) / stackalign) * stackalign;
+		parameter_type = (*sd->sl)[i].styp;
+		offset = (offset + align[parameter_type->flags&NQ]-1) & ~(align[parameter_type->flags&NQ]-1);
+		offset += szof(parameter_type);
 	}
-
 	return (offset + stackoffset);
 }
 
@@ -959,7 +965,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 			zmax offset = voff(obj);
 
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb xp 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb xp (%ld) %s;\n",
 					offset, regnames[reg]);
 			else
 			{
@@ -969,11 +975,11 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 					c.type = ZOP_CONSTANT;
 					c.val.constant = offset;
 					emit_add(fp, &zop_xp, &c, &zop_stack);
-					//fprintf(fp, "\t@add xp 0%+ld -> sp;\n", offset);
+					//fprintf(fp, "\t@add xp (%ld) -> sp;\n", offset);
 					fprintf(fp, "\t@storew sp 0 %s;\n", regnames[reg]);
 				}
 				else
-					fprintf(fp, "\t@storew xp 0%+ld %s;\n",
+					fprintf(fp, "\t@storew xp (%ld) %s;\n",
 						offset >> 1, regnames[reg]);
 			}
 			return;
@@ -988,7 +994,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 			{
 				fprintf(fp, "\t@storeb ");
 				emit_identifier(fp, obj);
-				fprintf(fp, " 0%+ld %s;\n",
+				fprintf(fp, " (%d) %s;\n",
 					obj->val.vlong, regnames[reg]);
 			}
 			else
@@ -997,7 +1003,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 				{
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> sp;\n",
+					fprintf(fp, " (%d) -> sp;\n",
 						obj->val.vlong);
 					fprintf(fp, "\t@storew sp 0 %s;\n",
 						regnames[reg]);
@@ -1006,7 +1012,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 				{
 					fprintf(fp, "\t@storew ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld %s;\n",
+					fprintf(fp, " (%d) %s;\n",
 						obj->val.vlong >> 1, regnames[reg]);
 				}
 			}
@@ -1014,7 +1020,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 #if 0
 		case EXTERN: /* External linkage */
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb _%s 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb _%s (%ld) %s;\n",
 					obj->v->identifier, offset, regnames[reg]);
 			else
 			{
@@ -1025,7 +1031,7 @@ static void write_reg(FILE* fp, struct obj* obj, int typf, int reg)
 
 		case STATIC: /* Static global */
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb STATIC_%s_%ld 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb STATIC_%s_%ld (%ld) %s;\n",
 					modulename, obj->v->offset, offset, regnames[reg]);
 			else
 				fprintf(fp, "\t@storew STATIC_%s_%ld 0 %s;\n",
@@ -1071,12 +1077,6 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 	int flags = obj->flags &
 		(KONST|REG|VAR|DREFOBJ|VARADR);
 
-	/* The only thing you can do with a function is to take the address of
-	 * it. */
-
-	if ((typf & NQ) == FUNKT)
-		flags &= ~DREFOBJ & ~VARADR;
-
 	/* Is this a memory dereference? */
 
 	if (flags & DREFOBJ)
@@ -1090,13 +1090,13 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 		struct zop r;
 		c.type = ZOP_CONSTANT;
 		//fprintf(fp, "\t@add ");
-		switch (typf & NQ)
+		switch (typf & NU)
 		{
 			case CHAR:		c.val.constant = obj->val.vchar;	break;
 			case UNSIGNED|CHAR:	c.val.constant = obj->val.vuchar;	break;
 			case SHORT:		c.val.constant = obj->val.vshort;	break;
 			case UNSIGNED|SHORT:	c.val.constant = obj->val.vushort;	break;
-		case POINTER:	      ierror(0);
+			case POINTER:		c.val.constant = obj->val.vulong;	break;
 			case INT:		c.val.constant = obj->val.vint;		break;
 			case UNSIGNED|INT:	c.val.constant = obj->val.vuint;	break;
 			default:
@@ -1127,7 +1127,7 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 			case REGISTER: /* Local variable */
 				if (flags & VARADR)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
+					fprintf(fp, "\t@add xp (%ld) -> %s;\n",
 						voff(obj), regnames[reg]);
 				}
 				else if (flags & REG)
@@ -1141,17 +1141,17 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 					zmax offset = voff(obj);
 
 					if ((typf & NQ) == CHAR)
-						fprintf(fp, "\t@loadb xp 0%+ld -> %s;\n",
+						fprintf(fp, "\t@loadb xp (%ld) -> %s;\n",
 							offset, regnames[reg]);
 					else
 					{
 						if (offset & 1)
 						{
-							fprintf(fp, "\t@add xp 0%+ld -> sp;\n", offset);
+							fprintf(fp, "\t@add xp (%ld) -> sp;\n", offset);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n", regnames[reg]);
 						}
 						else
-							fprintf(fp, "\t@loadw xp 0%+ld -> %s;\n",
+							fprintf(fp, "\t@loadw xp (%ld) -> %s;\n",
 								offset >> 1, regnames[reg]);
 					}
 				}
@@ -1170,12 +1170,12 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> %s;\n",
+					fprintf(fp, " (%d) -> %s;\n",
 						obj->val.vlong, regnames[reg]);
 				}
 				else if (strcmp(obj->v->identifier, "__va_start") == 0)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
+					fprintf(fp, "\t@add xp (%d) -> %s;\n",
 						find_varargs(), regnames[reg]);
 				}
 				else
@@ -1186,7 +1186,7 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 					{
 						fprintf(fp, "\t@loadb ");
 						emit_identifier(fp, obj);
-						fprintf(fp, " 0%+ld -> %s;\n",
+						fprintf(fp, " (%d) -> %s;\n",
 							obj->val.vlong, regnames[reg]);
 					}
 					else
@@ -1195,7 +1195,7 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 						{
 							fprintf(fp, "\t@add ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> sp;\n",
+							fprintf(fp, " (%d) -> sp;\n",
 								obj->val.vlong);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n",
 								regnames[reg]);
@@ -1204,7 +1204,7 @@ static void read_reg(FILE* fp, struct obj* obj, int typf, int reg)
 						{
 							fprintf(fp, "\t@loadw ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> %s;\n",
+							fprintf(fp, " (%d) -> %s;\n",
 								obj->val.vlong >> 1, regnames[reg]);
 						}
 					}
@@ -1224,13 +1224,13 @@ dereference:
 	obj->flags &= ~DREFOBJ;
 	read_reg(fp, obj, POINTER, 0);
 		
-	if (flags & DREFOBJ)
+	if ((flags & DREFOBJ) && typf != FUNKT)
 	{
 		switch (typf & NQ)
 		{
 			case CHAR:
 				fprintf(fp, "\t@loadb sp 0 -> %s;\n",
-					regnames[reg], regnames[reg]);
+					regnames[reg]);
 				break;
 
 			case SHORT:
@@ -1238,7 +1238,7 @@ dereference:
 			case POINTER:
 			case FUNKT:
 				fprintf(fp, "\t@loadw sp 0 -> %s;\n",
-					regnames[reg], regnames[reg]);
+					regnames[reg]);
 				break;
 
 			default:
@@ -1266,7 +1266,7 @@ static void push_value(FILE* fp, struct obj* obj, int typf, struct zop* op)
 			case UNSIGNED|SHORT:	op->val.constant = obj->val.vushort;	break;
 			case INT:		op->val.constant = obj->val.vint;	break;
 			case UNSIGNED|INT:	op->val.constant = obj->val.vuint;	break;
-		case POINTER:		ierror(0);
+			case POINTER:		op->val.constant = obj->val.vulong;	break;
 			default:
 				fprintf(fp, "XXX !!! bad konst type %X\n", typf);
 		}
@@ -1309,7 +1309,7 @@ static void push_value(FILE* fp, struct obj* obj, int typf, struct zop* op)
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == EXTERN) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr extern %s\n", obj->v->identifier);
 		op->type = ZOP_EXTERN;
@@ -1319,7 +1319,7 @@ static void push_value(FILE* fp, struct obj* obj, int typf, struct zop* op)
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == STATIC) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr static %ld\n", obj->v->offset);
 		op->type = ZOP_STATIC;
@@ -1404,7 +1404,7 @@ static void emit_zop(FILE* fp, struct zop* op)
 			return;
 
 		case ZOP_CONSTANT:
-			fprintf(fp, "0%+ld", (zshort)op->val.constant);
+			fprintf(fp, "(%d)", (zshort)op->val.constant);
 			return;
 
 		case ZOP_EXTERN:
@@ -1585,7 +1585,7 @@ static void move_long_value(FILE* fp, struct obj* q1, struct obj* z, int typf)
 		push_addrof(fp, z, POINTER, &zz);
 		fprintf(fp, "\t@call_vn __long_loadconst ");
 		emit_zop(fp, &zz);
-		fprintf(fp, " 0%+ld 0%+ld;\n", (short)hi, (short)lo);
+		fprintf(fp, " (%d) (%d);\n", (short)hi, (short)lo);
 		return;
 	}
 
@@ -1615,6 +1615,8 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 
     int c,t,lastcomp=0,reg;
 	    
+	if (fp == NULL) return;
+
     	function = func;
 
 	/* r0..r5 are always used for parameter passing. */
@@ -1626,6 +1628,13 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 	regused[6] = 1;
 	regused[7] = 1;
 
+	/* The indep code seems to underestimate the size of the frame for
+	 * some reason. For example, long f(long x) { return x; } requires
+	 * a temporary variable at xp(2), but stackframe remains 0.
+	 * I don't understand this bug yet. Anyway, +2 to compensate. */
+
+	stackframe += maxalign;
+
 	/* This is the offset of the stack frame, relative to the current stack
 	 * pointer. */
 
@@ -1666,7 +1675,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 	/* Adjust stack for locals. */
 
 	if (stackframe)
-		fprintf(fp, "\t@sub xp 0%+ld -> xp;\n", stackframe);
+		fprintf(fp, "\t@sub xp (%ld) -> xp;\n", stackframe);
 	//if (stackoffset)
 	//	fprintf(fp, "\txp = xp - %ld\n", stackframe);
 
@@ -1772,6 +1781,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						 * noop. */
 					case LONG:
 					case STRUCT:
+					case UNION:
 					case VOID:
 					case ARRAY:
 						break;
@@ -1809,6 +1819,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 
 					case LONG:
 					case STRUCT:
+					case UNION:
 					case VOID:
 					case ARRAY:
 #if 0
@@ -1862,18 +1873,46 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 				continue;
 
 			case KOMPLEMENT: /* Unary komplement */
-				/* INFORM BUG! */
-				/* The @not opcode doesn't work. We have to use a
-				 * wrapper function instead. */
-				
-				push_value(fp, &ic->q1, typf, &q1);
-				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@call_2s __not ");
-				emit_zop(fp, &q1);
-				fprintf(fp, " -> ");
-				emit_zop(fp, &z);
-				fprintf(fp, ";\n");
-				fin_zop(fp, &ic->z, typf, &z);
+				switch (typf & NQ)
+				{
+					case CHAR:
+					case SHORT:
+					case INT:
+						push_value(fp, &ic->q1, typf, &q1);
+						pop_value(fp, &ic->z, typf, &z);
+						if (g_flags[6] & USEDFLAG) {
+							/* Prior to Inform 6.30, the assembler
+							 * had a major bug in the @not opcode;
+							 * it would generate bogus code and
+							 * crash some Z-machine interpreters. */
+							fprintf(fp, "\t@call_2s __not ");
+						} else {
+							/* The bug was fixed in Inform 6.30.
+							 * The current distribution of Inform 6
+							 * is 6.31; the version distributed
+							 * with Inform 7 is 6.32. */
+							fprintf(fp, "\t@not ");
+						}
+						emit_zop(fp, &q1);
+						fprintf(fp, " -> ");
+						emit_zop(fp, &z);
+						fprintf(fp, ";\n");
+						fin_zop(fp, &ic->z, typf, &z);
+						break;
+
+					case LONG:
+						push_addrof(fp, &ic->z, typf, &z);
+						push_addrof(fp, &ic->q1, typf, &q1);
+						fprintf(fp, "\t@call_vn __long_not ");
+						emit_zop(fp, &q1);
+						fprintf(fp, " ");
+						emit_zop(fp, &z);
+						fprintf(fp, ";\n");
+						break;
+
+					default:
+						ierror(0);
+				}
 				continue;
 
 			case MOVEFROMREG: /* Write a register to memory */
@@ -1903,6 +1942,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						break;
 
 					case STRUCT:
+					case UNION:
 					case VOID:
 					case ARRAY:
 					assign_copy_struct:
@@ -1912,7 +1952,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						emit_zop(fp, &q1);
 						fprintf(fp, " ");
 						emit_zop(fp, &z);
-						fprintf(fp, " 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " (%d);\n", ic->q2.val.vlong);
 						break;
 
 					default:
@@ -1924,18 +1964,21 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					 AUTO or STATIC */
 				i = voff(&ic->q1);
 				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@add xp 0%+ld -> ", i);
+				fprintf(fp, "\t@add xp (%d) -> ", i);
 				emit_zop(fp, &z);
 				fprintf(fp, ";\n");
 				fin_zop(fp, &ic->z, typf, &z);
 				continue;
 
 			case PUSH: /* Push a value onto the stack */
-				fprintf(fp, "\t@sub xp 0%+ld -> xp;\n",
+				fprintf(fp, "\t@sub xp (%d) -> xp;\n",
 					ic->q2.val.vlong);
 				//stackoffset += ic->q2.val.vlong;
 				stackparamadjust += ic->q2.val.vlong;
 
+				if ((typf & NQ) == STRUCT || (typf & NQ) == UNION)
+					goto push_copy_struct;
+
 				switch (ic->q2.val.vlong)
 				{
 					case 1:
@@ -1953,10 +1996,11 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						break;
 
 					default:
+					push_copy_struct:
 						push_addrof(fp, &ic->q1, typf, &q1);
 						fprintf(fp, "\t@copy_table ");
 						emit_zop(fp, &q1);
-						fprintf(fp, " xp 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " xp (%d);\n", ic->q2.val.vlong);
 						break;
 				}
 				continue;
@@ -2060,7 +2104,13 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						/* Destination parameter first! */
 
 						push_addrof(fp, &ic->z, typf, &z);
-						push_addrof(fp, &ic->q2, typf, &q2);
+						if (code == LSHIFT || code == RSHIFT) {
+							if ((q2typ(ic) & NQ) != INT) ierror(0);
+							push_value(fp, &ic->q2, INT, &q2);
+						} else {
+							if ((q2typ(ic) & NQ) != LONG) ierror(0);
+							push_addrof(fp, &ic->q2, typf, &q2);
+						}
 						push_addrof(fp, &ic->q1, typf, &q1);
 
 						fprintf(fp, "\t@call_vn __long_");
@@ -2135,29 +2185,27 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 
 		case CONVERT:
 		  if((q1typ(ic)&NU)==CHAR){
-				switch (ztyp(ic) & NU)
+				switch (ztyp(ic) & NQ)
 				{
 					case CHAR:
-					case UNSIGNED|CHAR:
-					case UNSIGNED|SHORT:
-					case UNSIGNED|INT:
 					case SHORT:
 					case INT:
+					case POINTER:
 						push_value(fp, &ic->q1, CHAR, &q1);
 						pop_value(fp, &ic->z, typf, &z);
 						fprintf(fp, "\t@log_shift ");
 						emit_zop(fp, &q1);
 						fprintf(fp, " 8 -> sp;\n");
-						fprintf(fp, "\t@art_shift sp 0-8 -> ");
+						fprintf(fp, "\t@art_shift sp (-8) -> ");
 						emit_zop(fp, &z);
 						fprintf(fp, ";\n");
 						fin_zop(fp, &ic->z, typf, &z);
 						break;
 					
 					case LONG:
-						push_value(fp, &ic->q1, INT, &q1);
+						push_value(fp, &ic->q1, CHAR, &q1);
 						push_addrof(fp, &ic->z, typf, &z);
-						fprintf(fp, "\t@call_vn __long_fromchar");
+						fprintf(fp, "\t@call_vn __long_fromchar ");
 						emit_zop(fp, &z);
 						fprintf(fp, " ");
 						emit_zop(fp, &q1);
@@ -2176,26 +2224,21 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					case CHAR:
 					case SHORT:
 					case INT:
-						push_value(fp, &ic->q1, UNSIGNED|CHAR, &q1);
+					case POINTER:
+						push_value(fp, &ic->q1, CHAR, &q1);
 						pop_value(fp, &ic->z, typf, &z);
-						if ((z.type != ZOP_STACK) || (q1.type != ZOP_STACK))
-						{
-							emit_add(fp, &q1, &zop_zero, &z);
-#if 0
-							fprintf(fp, "\t@add ");
-							emit_zop(fp, &q1);
-							fprintf(fp, " 0 -> ");
-							emit_zop(fp, &z);
-							fprintf(fp, ";\n");
-#endif
-						}
+						fprintf(fp, "\t@and ");
+						emit_zop(fp, &q1);
+						fprintf(fp, " 255 -> ");
+						emit_zop(fp, &z);
+						fprintf(fp, ";\n");
 						fin_zop(fp, &ic->z, typf, &z);
 						break;
 					
 					case LONG:
 						push_value(fp, &ic->q1, UNSIGNED|CHAR, &q1);
 						push_addrof(fp, &ic->z, typf, &z);
-						fprintf(fp, "\t@call_vn __long_fromint");
+						fprintf(fp, "\t@call_vn __long_loadconst ");
 						emit_zop(fp, &z);
 						fprintf(fp, " 0 ");
 						emit_zop(fp, &q1);
@@ -2216,6 +2259,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					case UNSIGNED|INT:
 					case SHORT:
 					case INT:
+					case POINTER:
 						push_value(fp, &ic->q1, INT, &q1);
 						pop_value(fp, &ic->z, typf, &z);
 						if ((z.type != ZOP_STACK) || (q1.type != ZOP_STACK))
@@ -2233,6 +2277,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						break;
 
 					case LONG:
+					case UNSIGNED|LONG:
 						push_value(fp, &ic->q1, INT, &q1);
 						push_addrof(fp, &ic->z, typf, &z);
 						fprintf(fp, "\t@call_vn __long_fromint ");
@@ -2242,16 +2287,6 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						fprintf(fp, ";\n");
 						break;
 
-					case UNSIGNED|LONG:
-						push_value(fp, &ic->q1, INT, &q1);
-						push_addrof(fp, &ic->z, typf, &z);
-						fprintf(fp, "\t@call_vn __long_loadconst ");
-						emit_zop(fp, &z);
-						fprintf(fp, " 0 ");
-						emit_zop(fp, &q1);
-						fprintf(fp, ";\n");
-						break;
-					
 					default:
 						ierror(typf);
 				}
@@ -2264,6 +2299,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					case CHAR:
 					case SHORT:
 					case INT:
+					case POINTER:
 						push_value(fp, &ic->q1, INT, &q1);
 						pop_value(fp, &ic->z, typf, &z);
 						if ((z.type != ZOP_STACK) || (q1.type != ZOP_STACK))
@@ -2323,6 +2359,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 
 					case SHORT:
 					case INT:
+					case POINTER:
 						push_addrof(fp, &ic->q1, LONG, &q1);
 						pop_value(fp, &ic->z, typf, &z);
 						fprintf(fp, "\t@loadw ");
@@ -2333,6 +2370,16 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						fin_zop(fp, &ic->z, typf, &z);
 						break;
 					
+					case LONG:
+						push_addrof(fp, &ic->q1, LONG, &q1);
+						push_addrof(fp, &ic->z, typf, &z);
+						fprintf(fp, "\t@call_vn __long_copy ");
+						emit_zop(fp, &q1);
+						fprintf(fp, " ");
+						emit_zop(fp, &z);
+						fprintf(fp, ";\n");
+						break;
+
 					default:
 						ierror(typf & NQ);
 				}
@@ -2359,7 +2406,6 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					case CHAR:
 					case SHORT:
 					case INT:
-					case POINTER:
 						/* Second parameter first! */
 						push_value(fp, &ic->q2, typf, &compare2);
 						push_value(fp, &ic->q1, typf, &compare1);
@@ -2368,6 +2414,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 					case UNSIGNED|CHAR:
 					case UNSIGNED|SHORT:
 					case UNSIGNED|INT:
+					case POINTER:
 						/* Because the Z-machine only
 						 * has signed comparisons, we
 						 * need a dodgy algorithm to
@@ -2451,7 +2498,7 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 						q2.type = ZOP_CONSTANTADDR;
 						q2.val.constant = addconstant(0);
 						emit_zop(fp, &q2);
-						fprintf(fp, " -> sp;\n", i);
+						fprintf(fp, " -> sp;\n");
 						compare1.type = ZOP_STACK;
 						compare2.type = ZOP_CONSTANT;
 						compare2.val.constant = 0;
@@ -2545,12 +2592,10 @@ void gen_code(FILE* fp, struct IC *ic, struct Var* func, zmax stackframe)
 				/* If any parameters have been pushed, adjust
 				 * the stack to pop them. */
 
-				if (stackparamadjust)
-				{
-					fprintf(fp, "\t@add xp 0%+ld -> xp;\n",
-						stackparamadjust);
-					//stackoffset -= stackparamadjust;
-					stackparamadjust = 0;
+				int this_call_adjust = pushedargsize(ic);
+				if (this_call_adjust) {
+					fprintf(fp, "\t@add xp (%d) -> xp;\n", this_call_adjust);
+					stackparamadjust -= this_call_adjust;
 				}
 				continue;
 			}
@@ -2622,9 +2667,9 @@ void cleanup_cg(FILE *fp)
 
 		while (constant)
 		{
-			fprintf(fp, "Array CONSTANT_%s_%ld -->\n",
+			fprintf(fp, "Array CONSTANT_%s_%d -->\n",
 				modulename, constant->id);
-			fprintf(fp, " 0%+ld 0%+ld;\n",
+			fprintf(fp, " (%d) (%d);\n",
 				xword(constant->value, 1),
 				xword(constant->value, 0));
 			constant = constant->next;
@@ -2639,12 +2684,12 @@ void cleanup_cg(FILE *fp)
 		fprintf(fp, "[ __init_vars_%s;\n", modulename);
 		while (fixup)
 		{
-			fprintf(fp, "\t@add 0%+ld ", fixup->offset);
+			fprintf(fp, "\t@add (%ld) ", fixup->offset);
 
 			switch (fixup->value.type)
 			{
 				case STATIC:
-					fprintf(fp, "STATIC_%s_%ld -> sp;\n",
+					fprintf(fp, "STATIC_%s_%d -> sp;\n",
 						modulename, fixup->value.val.number);
 					break;
 
@@ -2660,15 +2705,15 @@ void cleanup_cg(FILE *fp)
 			switch (fixup->identifier.type)
 			{
 				case STATIC:
-					fprintf(fp, "\t@storew STATIC_%s_%ld 0%+ld sp;\n",
+					fprintf(fp, "\t@storew STATIC_%s_%d (%d) sp;\n",
 						modulename, fixup->identifier.val.number,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				case EXTERN:
-					fprintf(fp, "\t@storew _%s 0%+ld sp;\n",
+					fprintf(fp, "\t@storew _%s (%d) sp;\n",
 						fixup->identifier.val.identifier,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				default:
@@ -2685,18 +2730,17 @@ void cleanup_cg(FILE *fp)
 
 int reg_parm(struct reg_handle *rh, struct Typ *typ, int vararg, struct Typ *ft)
 {
-	/* Vararg parameters never go in registers. */
+	int s = sizetab[typ->flags & NQ];
 
+	/* Vararg parameters never go in registers. */
 	if (vararg)
 		return 0;
 
 	/* Will the parameter fit? */
-
-	if (sizetab[typ->flags & NQ] > 2)
+	if (s > sizetab[INT] || s <= 0)
 		return 0;
 
 	/* Still enough registers? */
-
 	if (rh->reg >= NUM_REGPARMS+USERREG)
 		return 0;
 
diff --git a/vbcc/machines/z/machine.h b/vbcc/machines/z/machine.h
index 6f43fc8..3eb7864 100644
--- a/vbcc/machines/z/machine.h
+++ b/vbcc/machines/z/machine.h
@@ -18,7 +18,7 @@ struct AddressingMode{
 
 /* Number of command-line options we accept. */
 
-#define MAXGF 6
+#define MAXGF 8
 
 /* If this is set to zero vbcc will not generate ICs where the target operand
  * is the same as the 2nd source operand. This can sometimes simplify the
@@ -57,6 +57,10 @@ struct AddressingMode{
 
 #define INLINEMEMCPY 65536
 
+/* Do we want to inline calls to puts() and printf()? */
+
+#define INLINE_PUTS_ON_Z_MACHINE 1
+
 /* Do we want to pass parameters to functions in registers? */
 
 #define HAVE_REGPARMS 1
diff --git a/vbcc/preproc.c b/vbcc/preproc.c
index 54f6701..d835333 100644
--- a/vbcc/preproc.c
+++ b/vbcc/preproc.c
@@ -429,6 +429,7 @@ struct strnode *AllocSpace()
             newnode->flags = newnode->number = 0;
             return (newnode);
         }
+        free(newstr);
     }
     return (NULL);
 }
diff --git a/vbcc/regs.c b/vbcc/regs.c
index 24f9157..7162a87 100644
--- a/vbcc/regs.c
+++ b/vbcc/regs.c
@@ -1361,7 +1361,7 @@ int find_best_local_reg(IC *fp,Var *v,int preferred)
     }
 
     /* check for register arguments */
-    if((p->z.flags&(VAR|DREFOBJ))==VAR&&!*p->z.v->identifier&&p->z.v->reg){
+    if(p!=fp&&(p->z.flags&(VAR|DREFOBJ))==VAR&&!*p->z.v->identifier&&p->z.v->reg){
       if(p->code==ASSIGN&&(p->q1.flags&(VAR|DREFOBJ))==VAR&&p->q1.v==v){
 	savings[abs(p->z.v->reg)]++;
       }else{
diff --git a/vbcc/statements.c b/vbcc/statements.c
index 4b8e352..e9c26e9 100644
--- a/vbcc/statements.c
+++ b/vbcc/statements.c
@@ -278,14 +278,15 @@ void if_statement(void)
   }
   next_token();
   lout=++label;
+  nocode=cm;
   if(cexpr!=2){
     new=new_IC();
     new->code=BRA;
     new->typf=lout;
     add_IC(new);
   }
-  if(cexpr!=1) {nocode=cm;gen_label(lfalse);}
-  if(cexpr==1) nocode=1; else nocode=cm;
+  if(cexpr!=1) gen_label(lfalse);
+  if(cexpr==1) nocode=1;
   if(ctok->type!=LBRA){
 	  if(ctok->type!=NAME||strcmp("if",ctok->name)) {
 #ifdef HAVE_MISRA
diff --git a/vbcc/type_expr.c b/vbcc/type_expr.c
index ee81ec9..112e294 100644
--- a/vbcc/type_expr.c
+++ b/vbcc/type_expr.c
@@ -791,7 +791,7 @@ int type_expression2(np p,type *ttyp)
       p->ntyp->flags=CONST|INT;
     }
     p->o.v=v;
-	if (p->ntyp->flags&VOLATILE) p->sidefx=1; /* Touching a volatile may have side effects */
+	if (f==IDENTIFIER&&(p->ntyp->flags&VOLATILE)) p->sidefx=1; /* Touching a volatile may have side effects */
     return 1;
   }
 
@@ -802,9 +802,7 @@ int type_expression2(np p,type *ttyp)
     return 1;
   }
 
-  if(f==BITFIELD) return 1;
-
-  if(f==LITERAL){
+  if(f==BITFIELD||f==LITERAL){
     p->lvalue=1;
     return 1;
   }
@@ -923,7 +921,7 @@ int type_expression2(np p,type *ttyp)
     if(ISVECTOR(p->right->ntyp->flags)){
       p->ntyp=new_typ();
       if(ISFLOAT(VECTYPE(p->right->ntyp->flags)))
-	p->ntyp->flags=mkvec(INT,VECDIM(p->left->ntyp->flags));
+	p->ntyp->flags=mkvec(INT,VECDIM(p->right->ntyp->flags));
       else
 	p->ntyp->flags=p->right->ntyp->flags&NQ;
       return ok;
@@ -2208,7 +2206,7 @@ int alg_opt(np p,type *ttyp)
     }
     if(c==2){
         /*  a+0=a-0=a^0=a>>0=a<<0=a*1=a/1=a   */
-        if(((eins2==1&&(f==MULT||f==PMULT||f==DIV))||(null2&&(f==ADD||f==SUB||f==OR||f==XOR||f==LSHIFT||f==RSHIFT)))&&!p->right->sidefx){
+        if(((eins2==1&&(f==MULT||f==PMULT||f==DIV))||(null2&&(f==ADD||f==SUB||f==OR||f==XOR||f==LSHIFT||f==RSHIFT)))&&!p->right->sidefx&&(p->left->ntyp->flags==p->ntyp->flags)){
             if(DEBUG&1){if(f==MULT||f==PMULT||f==DIV) printf("a*/1->a\n"); else printf("a+-^0->a\n");}
             free_expression(p->right);
             merk=p->left;
@@ -2219,7 +2217,7 @@ int alg_opt(np p,type *ttyp)
             return type_expression2(p,ttyp);
         }
         /*  a*0=0   */
-        if(null2&&(f==MULT||f==PMULT||f==AND||f==DIV||f==MOD)){
+        if(null2&&(f==MULT||f==PMULT||f==AND||f==DIV||f==MOD)&&!p->sidefx&&(p->left->ntyp->flags==p->ntyp->flags)){
             if(DEBUG&1) printf("a*&/%%0->0\n");
             if(null2&&(f==DIV||f==MOD)) error(84);
             if(p->flags==PMULT) p->flags=PCEXPR; else p->flags=CEXPR;
@@ -2227,13 +2225,13 @@ int alg_opt(np p,type *ttyp)
 	    eval_const(&gval,INT);
             /*  hier nur int,long,float,double moeglich, hoffe ich  */
             insert_constn(p);
-            if(!p->left->sidefx){free_expression(p->left);p->left=0;} else make_cexpr(p->left);
-            if(!p->right->sidefx){free_expression(p->right);p->right=0;} else make_cexpr(p->right);
+            free_expression(p->left);p->left=0;
+            free_expression(p->right);p->right=0;
 
 /*            return(type_expression2(p,ttyp));   */
             return 1;
         }
-        if(eins2==-1&&(f==MULT||f==PMULT||f==DIV)&&!p->right->sidefx){
+        if(eins2==-1&&(f==MULT||f==PMULT||f==DIV)&&!p->right->sidefx&&(p->left->ntyp->flags==p->ntyp->flags)){
             if(DEBUG&1) printf("a*/(-1)->-a\n");
             free_expression(p->right);
             p->right=0;
@@ -2296,33 +2294,20 @@ int alg_opt(np p,type *ttyp)
             return type_expression2(p,ttyp);
         }
         /*  0/a=0   */
-        if(null1&&(f==DIV||f==MOD||f==LSHIFT||f==RSHIFT)){
+        if(null1&&(f==DIV||f==MOD||f==LSHIFT||f==RSHIFT)&&!p->sidefx){
             if(DEBUG&1) printf("0/%%<<>>a->0\n");
             p->flags=CEXPR;
 	    gval.vint=zm2zi(l2zm(0L));
 	    eval_const(&gval,INT);
             insert_constn(p);
-            if(!p->left->sidefx){free_expression(p->left);p->left=0;}else make_cexpr(p->left);
-            if(!p->right->sidefx){free_expression(p->right);p->right=0;} else make_cexpr(p->right);
+            free_expression(p->left);p->left=0;
+            free_expression(p->right);p->right=0;
 	    dontopt=0;
             return type_expression2(p,ttyp);
         }
     }
     return 1;
 }
-void make_cexpr(np p)
-/*  Macht aus einem Knoten, der durch constant-folding ueberfluessig    */
-/*  wurde, eine PCEXPR, sofern er keine Nebenwirkungen von sich aus     */
-/*  erzeugt. Hier noch ueberpruefen, ob CEXPR besser waere.             */
-/*  Fuehrt rekursiven Abstieg durch. Ist das so korrekt?                */
-{
-    int f=p->flags;
-    if(f!=ASSIGN&&f!=ASSIGNOP&&f!=CALL&&f!=POSTINC&&f!=POSTDEC&&f!=PREINC&&f!=PREDEC&&f!=LAND&&f!=LOR){
-        p->flags=PCEXPR;
-        if(p->left) make_cexpr(p->left);
-        if(p->right) make_cexpr(p->right);
-    }
-}
 int test_assignment(type *zt,np q)
 /*  testet, ob q an Typ z zugewiesen werden darf    */
 {
